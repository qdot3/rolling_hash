# 設計図

## 提供するアイテム

- `Prime` + `SupportedPrime` + `PRIMES`：特定の素数`P`だけに対応。高速な除算のために必要
- `BaseCount` + `SupportedBaseCount`：特定の数の基数にだけ対応。計算時間が基数の数`B`に比例して増大するため、少数に限定。
- `OneWay`：一方向にハッシュ化。配列の延長ができる。
- `TwoWay`：双方向にハッシュ化。値の追加はできないが、回文のチェックができる。
- `Maybe`：ハッシュが衝突している可能性を明示。

## 実装メモ

- 抽象化（`Hash` + `Hasher`）について
  - `Hash`は必要。さまざまな型を受け取りたい。
    - `Into<u64>`は所有権をとるのでスライスを受け取りにくい
  - `Hasher`は不要。ハッシュ値の計算と記録がセットだから。
  - 1つの素数の法といくつかの基数について計算出来れば十分。複数の法が欲しい場合はまとめるためのラッパーを用意する。
- 配列のハッシュ化は、問い合わせ（`-> u64`）と追加や初期化（`-> Vec<u64>`）で異なる
- 多次元ベクトルをハッシュ化する際は、一番外側のインデックスごとに1要素とする。3次元以上では、同じ要素の列に`flatten`できれば衝突してしまうが、あきらめる。
- 基数のRNGを選べるようにする。`rand`の依存性はオプション。
- 部分列のハッシュ値の計算
  1. 引き算なら長さを固定できる
  2. 足し算なら`+ P`を1つ削減できるが、長さが異なる部分列が衝突する可能性がでてくる
- 異なる型の列の問い合わせ
  1. `&[Box<dyn Hash>]`用のメソッドを生やす。実装は楽だが、動的ディスパッチにコストがかかり、ヒープに不連続にアクセスする恐れもある。運が良ければ並列化されるかも
  2. `BinaryHeap::peek()`みたいに、専用の型を生やして値を追加する度にハッシュ値を計算する。法と基数が一致しないと破綻するので仕方ない。ゼロコスト。
  3. そもそも異なる型をサポートしない。これが正解かも。`PhantomData`を使う。
